<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AICWD — Cognitive Waste Index Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(255, 255, 255, 0.045);
      --panel-2: rgba(255, 255, 255, 0.065);
      --stroke: rgba(255, 255, 255, 0.10);
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.62);
      --muted-2: rgba(255, 255, 255, 0.42);

      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --cyan: #22d3ee;
      --blue: #60a5fa;
      --purple: #a78bfa;
      --pink: #fb7185;

      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 16px;
      --radius-sm: 12px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

      --grid-gap: 14px;
      --header-h: 76px;
      --footer-h: 62px;

      --waste-alert: 2.5; /* multiplier */
      --drift-alert: 0.7;
      --stress-alert: 2.0;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: radial-gradient(1100px 700px at 18% 10%, rgba(34,211,238,0.09), transparent 60%),
                  radial-gradient(900px 650px at 70% 18%, rgba(167,139,250,0.09), transparent 60%),
                  radial-gradient(900px 700px at 45% 85%, rgba(96,165,250,0.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    a { color: inherit; }

    .wrap {
      max-width: 1320px;
      margin: 0 auto;
      padding: 18px 18px 28px;
    }

    header {
      height: var(--header-h);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      padding: 14px 16px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: sticky;
      top: 14px;
      z-index: 10;
      backdrop-filter: blur(10px);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 240px;
    }

    .logo {
      width: 42px;
      height: 42px;
      border-radius: 14px;
      background: linear-gradient(145deg, rgba(34,211,238,0.35), rgba(167,139,250,0.25));
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
    }

    .logo:before {
      content: "";
      position: absolute;
      left: -20px;
      top: -20px;
      width: 70px;
      height: 70px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.55), transparent 55%);
      transform: rotate(20deg);
      opacity: 0.35;
    }

    .brand h1 {
      font-size: 16px;
      line-height: 1.15;
      margin: 0;
      letter-spacing: 0.5px;
    }

    .brand .sub {
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.22);
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245,158,11,0.18);
    }

    .btn {
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      outline: none;
    }

    .btn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.085); }
    .btn:active { transform: translateY(0px); }
    .btn:focus-visible { box-shadow: 0 0 0 4px rgba(34,211,238,0.15); }

    .btn-danger {
      background: rgba(239,68,68,0.14);
      border-color: rgba(239,68,68,0.28);
    }

    .btn-danger:hover { background: rgba(239,68,68,0.18); }

    .btn-ghost {
      background: transparent;
    }

    .select {
      appearance: none;
      background: rgba(0,0,0,0.18);
      color: var(--text);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    }

    .select:focus-visible { box-shadow: 0 0 0 4px rgba(167,139,250,0.18); }

    main {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: minmax(360px, 1fr) minmax(360px, 1fr);
      gap: var(--grid-gap);
      align-items: stretch;
    }

    @media (max-width: 980px) {
      header { position: static; height: auto; }
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }
    }

    .panel {
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.055), rgba(255,255,255,0.03));
      box-shadow: var(--shadow);
      padding: 14px;
      overflow: hidden;
      position: relative;
    }

    .panel:before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(650px 340px at 10% 10%, rgba(34,211,238,0.08), transparent 50%);
      opacity: 0.8;
      pointer-events: none;
    }

    .panel-header {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 12px;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 14px;
      letter-spacing: 0.35px;
      color: rgba(255,255,255,0.88);
    }

    .panel-header .meta {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .kpi {
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .kpi .value {
      font-size: 34px;
      letter-spacing: 0.5px;
      font-weight: 700;
    }

    .kpi .label {
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
    }

    .kpi-block {
      display: grid;
      gap: 3px;
      min-width: 120px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .chart-wrap {
      position: relative;
      z-index: 1;
      height: calc(100% - 44px);
      min-height: 280px;
    }

    .gauge-wrap {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      height: calc(100% - 44px);
      align-items: center;
      justify-items: center;
    }

    .gauge {
      width: min(340px, 90%);
      aspect-ratio: 1 / 1;
      position: relative;
    }

    #gaugeCanvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    .gauge-center {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      pointer-events: none;
    }

    .gauge-center .big {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: 0.6px;
    }

    .gauge-center .small {
      color: var(--muted);
      margin-top: 4px;
      font-size: 12px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      color: var(--muted);
      font-size: 12px;
    }

    .badge strong { color: var(--text); font-weight: 700; }

    .heatmap {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 6px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
    }

    .cell {
      aspect-ratio: 1 / 1;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.03);
      transition: transform 120ms ease, box-shadow 120ms ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }

    .cell .tip {
      position: absolute;
      inset: auto 6px 6px 6px;
      font-size: 10px;
      color: rgba(255,255,255,0.72);
      text-shadow: 0 2px 8px rgba(0,0,0,0.55);
      opacity: 0.0;
      transform: translateY(4px);
      transition: opacity 140ms ease, transform 140ms ease;
      pointer-events: none;
    }

    .cell:hover .tip {
      opacity: 1.0;
      transform: translateY(0px);
    }

    footer {
      margin-top: 14px;
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.18);
      height: var(--footer-h);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      color: var(--muted);
      font-size: 12px;
    }

    .alerts {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .alert {
      cursor: pointer;
      border-radius: 12px;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: rgba(255,255,255,0.8);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      max-width: 460px;
    }

    .alert .tag {
      font-size: 11px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(239,68,68,0.14);
      border: 1px solid rgba(239,68,68,0.30);
      color: rgba(255,255,255,0.92);
      flex: 0 0 auto;
    }

    .alert .txt {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--muted);
      font-size: 12px;
    }

    /* modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.74);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 50;
    }

    .modal.open { display: flex; }

    .modal-card {
      width: min(980px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.04));
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow: hidden;
    }

    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }

    .modal-title {
      font-size: 14px;
      margin: 0;
      color: rgba(255,255,255,0.92);
      letter-spacing: 0.4px;
    }

    .modal-body {
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    @media (max-width: 860px) {
      .grid-2 { grid-template-columns: 1fr; }
    }

    .card {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.20);
      padding: 12px;
      overflow: hidden;
    }

    .card h3 {
      margin: 0 0 8px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.25px;
      text-transform: uppercase;
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      line-height: 1.45;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>AICWD — Cognitive Waste Index</h1>
          <div class="sub">Static-first, real-time SSE dashboard · Forensic drill-down · Red-team stress</div>
        </div>
      </div>

      <div class="controls">
        <span class="pill" id="connPill" title="SSE connection state">
          <span class="dot" id="connDot"></span>
          <span id="connText">Connecting…</span>
        </span>

        <select class="select" id="heatmapRange" title="Heatmap time range">
          <option value="5m">Heatmap: 5 min</option>
          <option value="30m">Heatmap: 30 min</option>
          <option value="2h" selected>Heatmap: 2 hours</option>
          <option value="24h">Heatmap: 24 hours</option>
        </select>

        <button class="btn btn-danger" id="btnStress">Initiate Stress Test</button>
        <button class="btn btn-ghost" id="btnClear">Clear Alerts</button>
      </div>
    </header>

    <main>
      <!-- Top-left: Token efficiency scatter (live) -->
      <section class="panel" aria-label="Token efficiency scatter">
        <div class="panel-header">
          <h2>Token Efficiency Scatter</h2>
          <div class="meta">
            <span class="badge"><strong id="kpiTokens">–</strong> tokens</span>
            <span class="badge"><strong id="kpiLatency">–</strong> ms</span>
            <span class="badge"><strong id="kpiModel">–</strong></span>
          </div>
        </div>
        <div class="chart-wrap">
          <canvas id="chartScatter"></canvas>
        </div>
      </section>

      <!-- Top-right: Cognitive Waste Index gauge -->
      <section class="panel" aria-label="Cognitive Waste Index gauge">
        <div class="panel-header">
          <h2>Cognitive Waste Index (0–100)</h2>
          <div class="meta">
            <span class="badge">Alert: <strong>&gt; 2.5×</strong></span>
            <span class="badge">Drift: <strong>&gt; 0.7</strong></span>
          </div>
        </div>
        <div class="gauge-wrap">
          <div class="gauge">
            <canvas id="gaugeCanvas" width="420" height="420"></canvas>
            <div class="gauge-center">
              <div class="big" id="gaugeValue">–</div>
              <div class="small">Waste multiplier: <span id="gaugeMult">–</span></div>
            </div>
          </div>
          <div class="kpi">
            <div class="kpi-block">
              <div class="value" id="kpiWasteMult">–</div>
              <div class="label">Waste multiplier</div>
            </div>
            <div class="kpi-block">
              <div class="value" id="kpiDrift">–</div>
              <div class="label">Semantic drift</div>
            </div>
            <div class="kpi-block">
              <div class="value" id="kpiStress">–</div>
              <div class="label">Adversarial stress</div>
            </div>
          </div>
        </div>
      </section>

      <!-- Bottom-left: semantic drift timeline -->
      <section class="panel" aria-label="Semantic drift timeline">
        <div class="panel-header">
          <h2>Semantic Drift Timeline</h2>
          <div class="meta">
            <span id="driftMeta">–</span>
          </div>
        </div>
        <div class="chart-wrap">
          <canvas id="chartDrift"></canvas>
        </div>
      </section>

      <!-- Bottom-right: adversarial stress + heatmap -->
      <section class="panel" aria-label="Adversarial stress indicator">
        <div class="panel-header">
          <h2>Adversarial Stress + Heatmap</h2>
          <div class="meta">
            <span id="stressMeta">–</span>
          </div>
        </div>

        <div class="chart-wrap" style="display:grid; grid-template-rows: 1fr auto; gap: 12px;">
          <div style="min-height: 220px;">
            <canvas id="chartStress"></canvas>
          </div>
          <div>
            <div class="badge" style="margin-bottom: 10px;">Click a cell for forensic details</div>
            <div class="heatmap" id="heatmap"></div>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <div>
        <div style="color: rgba(255,255,255,0.82)">Live stream:</div>
        <div style="margin-top: 2px; color: var(--muted)">
          <span id="sseUrl">–</span>
        </div>
      </div>
      <div class="alerts" id="alerts"></div>
    </footer>
  </div>

  <!-- Forensic modal -->
  <div class="modal" id="modal" role="dialog" aria-modal="true" aria-label="Forensic details">
    <div class="modal-card">
      <div class="modal-head">
        <h3 class="modal-title" id="modalTitle">Forensic Event</h3>
        <button class="btn" id="btnClose">Close</button>
      </div>
      <div class="modal-body">
        <div class="grid-2">
          <div class="card">
            <h3>Metrics</h3>
            <pre id="modalMetrics">–</pre>
          </div>
          <div class="card">
            <h3>Context</h3>
            <pre id="modalContext">–</pre>
          </div>
        </div>
        <div class="grid-2">
          <div class="card">
            <h3>Prompt</h3>
            <pre id="modalPrompt">–</pre>
          </div>
          <div class="card">
            <h3>Response</h3>
            <pre id="modalResponse">–</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const CONVEX_BASE = "https://tacit-wombat-870.convex.cloud";
      const SSE_URL = `${CONVEX_BASE}/api/metrics/stream`;

      const els = {
        connDot: document.getElementById("connDot"),
        connText: document.getElementById("connText"),
        sseUrl: document.getElementById("sseUrl"),

        kpiTokens: document.getElementById("kpiTokens"),
        kpiLatency: document.getElementById("kpiLatency"),
        kpiModel: document.getElementById("kpiModel"),

        gaugeValue: document.getElementById("gaugeValue"),
        gaugeMult: document.getElementById("gaugeMult"),
        kpiWasteMult: document.getElementById("kpiWasteMult"),
        kpiDrift: document.getElementById("kpiDrift"),
        kpiStress: document.getElementById("kpiStress"),

        driftMeta: document.getElementById("driftMeta"),
        stressMeta: document.getElementById("stressMeta"),

        heatmap: document.getElementById("heatmap"),
        heatmapRange: document.getElementById("heatmapRange"),

        alerts: document.getElementById("alerts"),

        btnStress: document.getElementById("btnStress"),
        btnClear: document.getElementById("btnClear"),

        modal: document.getElementById("modal"),
        modalTitle: document.getElementById("modalTitle"),
        modalMetrics: document.getElementById("modalMetrics"),
        modalContext: document.getElementById("modalContext"),
        modalPrompt: document.getElementById("modalPrompt"),
        modalResponse: document.getElementById("modalResponse"),
        btnClose: document.getElementById("btnClose"),

        gaugeCanvas: document.getElementById("gaugeCanvas"),
      };

      els.sseUrl.textContent = SSE_URL;

      const thresholds = {
        waste: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--waste-alert")) || 2.5,
        drift: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--drift-alert")) || 0.7,
        stress: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--stress-alert")) || 2.0,
      };

      const state = {
        history: [],
        alerts: [],
        campaignId: null,
        lastBeepAt: 0,
      };

      function fmt(n, digits = 2) {
        if (n === null || n === undefined || !Number.isFinite(Number(n))) return "–";
        return Number(n).toFixed(digits);
      }

      function fmtInt(n) {
        if (n === null || n === undefined || !Number.isFinite(Number(n))) return "–";
        return String(Math.round(Number(n)));
      }

      function ts(ms) {
        const d = new Date(ms);
        return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      }

      function setConn(status) {
        if (status === "ok") {
          els.connDot.style.background = "var(--good)";
          els.connDot.style.boxShadow = "0 0 0 3px rgba(34,197,94,0.18)";
          els.connText.textContent = "Live SSE";
          return;
        }
        if (status === "warn") {
          els.connDot.style.background = "var(--warn)";
          els.connDot.style.boxShadow = "0 0 0 3px rgba(245,158,11,0.18)";
          els.connText.textContent = "Reconnecting…";
          return;
        }
        els.connDot.style.background = "var(--bad)";
        els.connDot.style.boxShadow = "0 0 0 3px rgba(239,68,68,0.18)";
        els.connText.textContent = "Disconnected";
      }

      function playBeep() {
        const now = Date.now();
        if (now - state.lastBeepAt < 2500) return;
        state.lastBeepAt = now;

        try {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          const ctx = new AudioCtx();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();

          osc.type = "sine";
          osc.frequency.value = 880;

          gain.gain.value = 0.0001;
          osc.connect(gain);
          gain.connect(ctx.destination);

          const t0 = ctx.currentTime;
          gain.gain.exponentialRampToValueAtTime(0.10, t0 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

          osc.start(t0);
          osc.stop(t0 + 0.25);
          osc.onended = () => ctx.close();
        } catch {
          // ignored
        }
      }

      function wasteToGauge(wasteMult) {
        return Math.max(0, Math.min(100, Math.round((Number(wasteMult) || 0) * 20)));
      }

      function gaugeColor(value0to100) {
        if (value0to100 < 35) return "#22c55e";
        if (value0to100 < 65) return "#f59e0b";
        return "#ef4444";
      }

      function drawGauge(value0to100) {
        const canvas = els.gaugeCanvas;
        const ctx = canvas.getContext("2d");
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const r = Math.min(w, h) * 0.38;

        ctx.clearRect(0, 0, w, h);

        // background ring
        ctx.lineWidth = 22;
        ctx.lineCap = "round";

        const start = Math.PI * 0.75;
        const end = Math.PI * 2.25;

        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,0.09)";
        ctx.arc(cx, cy, r, start, end);
        ctx.stroke();

        // value arc
        const t = start + (end - start) * (value0to100 / 100);
        ctx.beginPath();
        ctx.strokeStyle = gaugeColor(value0to100);
        ctx.arc(cx, cy, r, start, t);
        ctx.stroke();

        // tick marks
        ctx.save();
        ctx.translate(cx, cy);
        for (let i = 0; i <= 10; i++) {
          const p = i / 10;
          const a = start + (end - start) * p;
          const x1 = Math.cos(a) * (r - 22);
          const y1 = Math.sin(a) * (r - 22);
          const x2 = Math.cos(a) * (r - (i % 5 === 0 ? 8 : 14));
          const y2 = Math.sin(a) * (r - (i % 5 === 0 ? 8 : 14));
          ctx.beginPath();
          ctx.strokeStyle = i % 5 === 0 ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.10)";
          ctx.lineWidth = i % 5 === 0 ? 3 : 2;
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();

        // needle
        ctx.save();
        ctx.translate(cx, cy);
        const needleA = start + (end - start) * (value0to100 / 100);
        ctx.rotate(needleA + Math.PI / 2);
        ctx.beginPath();
        ctx.fillStyle = "rgba(255,255,255,0.86)";
        ctx.moveTo(-4, 0);
        ctx.lineTo(4, 0);
        ctx.lineTo(0, -r + 16);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // hub
        ctx.beginPath();
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.arc(cx, cy, 7, 0, Math.PI * 2);
        ctx.fill();
      }

      function addAlert(kind, point, note) {
        const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
        state.alerts.unshift({ id, kind, point, note });
        state.alerts = state.alerts.slice(0, 6);
        renderAlerts();
      }

      function renderAlerts() {
        els.alerts.innerHTML = "";
        for (const a of state.alerts) {
          const el = document.createElement("div");
          el.className = "alert";
          el.innerHTML = `<span class="tag">${a.kind}</span><span class="txt">${a.note}</span>`;
          el.onclick = () => openForensics(a.point, `${a.kind} · ${a.note}`);
          els.alerts.appendChild(el);
        }
      }

      function openForensics(point, title) {
        els.modalTitle.textContent = title;
        els.modalMetrics.textContent = JSON.stringify({
          created_at: point.created_at,
          model: point.model,
          tokens: point.tokens,
          latency: point.latency,
          token_efficiency: point.token_efficiency,
          drift: point.drift,
          waste_index: point.waste_index,
          stress: point.stress,
        }, null, 2);

        els.modalContext.textContent = JSON.stringify({
          waste_multiplier_threshold: thresholds.waste,
          drift_threshold: thresholds.drift,
          stress_threshold: thresholds.stress,
          sse_url: SSE_URL,
        }, null, 2);

        els.modalPrompt.textContent = point.prompt || "";
        els.modalResponse.textContent = point.response || "";

        els.modal.classList.add("open");
      }

      function closeForensics() {
        els.modal.classList.remove("open");
      }

      els.btnClose.addEventListener("click", closeForensics);
      els.modal.addEventListener("click", (e) => {
        if (e.target === els.modal) closeForensics();
      });
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeForensics();
      });

      function colorForWaste(mult) {
        const v = Math.max(0, Math.min(5, Number(mult) || 0));
        const t = v / 5;

        // green -> amber -> red
        const r = t < 0.5 ? Math.round(34 + (245 - 34) * (t / 0.5)) : Math.round(245 + (239 - 245) * ((t - 0.5) / 0.5));
        const g = t < 0.5 ? Math.round(197 + (158 - 197) * (t / 0.5)) : Math.round(158 + (68 - 158) * ((t - 0.5) / 0.5));
        const b = t < 0.5 ? Math.round(94 + (11 - 94) * (t / 0.5)) : Math.round(11 + (68 - 11) * ((t - 0.5) / 0.5));

        return `rgba(${r},${g},${b},0.95)`;
      }

      function cellsForRange(range) {
        if (range === "5m") return 12;
        if (range === "30m") return 36;
        if (range === "24h") return 144;
        return 72; // 2h
      }

      function renderHeatmap() {
        const range = els.heatmapRange.value;
        const count = cellsForRange(range);
        const points = state.history.slice(0, count).reverse();

        els.heatmap.innerHTML = "";

        // Reconfigure grid columns for larger ranges.
        const cols = range === "24h" ? 18 : 12;
        els.heatmap.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        for (let i = 0; i < count; i++) {
          const p = points[i] || null;
          const cell = document.createElement("div");
          cell.className = "cell";

          if (p) {
            cell.style.background = colorForWaste(p.waste_index);
            cell.title = `${ts(p.created_at)} · waste ${fmt(p.waste_index, 2)}× · drift ${fmt(p.drift, 2)} · stress ${fmt(p.stress, 2)}×`;
            const tip = document.createElement("div");
            tip.className = "tip";
            tip.textContent = fmt(p.waste_index, 2) + "×";
            cell.appendChild(tip);
            cell.onclick = () => openForensics(p, `Heatmap cell · ${ts(p.created_at)}`);
          } else {
            cell.style.background = "rgba(255,255,255,0.03)";
          }

          els.heatmap.appendChild(cell);
        }
      }

      // ----- Charts -----
      Chart.defaults.color = "rgba(255,255,255,0.75)";
      Chart.defaults.borderColor = "rgba(255,255,255,0.10)";
      Chart.defaults.font.family = getComputedStyle(document.body).fontFamily;

      const scatterCtx = document.getElementById("chartScatter");
      const driftCtx = document.getElementById("chartDrift");
      const stressCtx = document.getElementById("chartStress");

      const scatterChart = new Chart(scatterCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "token_efficiency vs latency",
              data: [],
              pointRadius: 4,
              pointHoverRadius: 7,
              backgroundColor: "rgba(34,211,238,0.85)",
              borderColor: "rgba(34,211,238,0.35)",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const p = ctx.raw;
                  return `latency ${fmt(p.x, 0)}ms · eff ${fmt(p.y, 2)} tokens/unit`;
                },
              },
            },
          },
          scales: {
            x: {
              title: { display: true, text: "Latency (ms)" },
              grid: { color: "rgba(255,255,255,0.06)" },
            },
            y: {
              title: { display: true, text: "Token efficiency (tokens / semantic unit)" },
              grid: { color: "rgba(255,255,255,0.06)" },
            },
          },
        },
      });

      const driftChart = new Chart(driftCtx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "semantic drift",
              data: [],
              borderWidth: 2,
              tension: 0.25,
              pointRadius: 0,
              borderColor: "rgba(167,139,250,0.85)",
              backgroundColor: "rgba(167,139,250,0.12)",
              fill: true,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: { intersect: false, mode: "index" },
          },
          scales: {
            x: {
              grid: { color: "rgba(255,255,255,0.06)" },
              ticks: { maxTicksLimit: 6 },
            },
            y: {
              suggestedMin: 0,
              suggestedMax: 1,
              grid: { color: "rgba(255,255,255,0.06)" },
            },
          },
        },
      });

      const stressChart = new Chart(stressCtx, {
        type: "bar",
        data: {
          labels: [],
          datasets: [
            {
              label: "stress",
              data: [],
              borderWidth: 1,
              backgroundColor: "rgba(251,113,133,0.40)",
              borderColor: "rgba(251,113,133,0.70)",
              borderRadius: 8,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { grid: { display: false }, ticks: { maxTicksLimit: 8 } },
            y: { grid: { color: "rgba(255,255,255,0.06)" }, suggestedMin: 0, suggestedMax: 4 },
          },
        },
      });

      function pushSeries(chart, label, value, maxPoints = 50) {
        chart.data.labels.push(label);
        chart.data.datasets[0].data.push(value);
        if (chart.data.labels.length > maxPoints) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update("none");
      }

      function pushScatter(point, maxPoints = 80) {
        const ds = scatterChart.data.datasets[0].data;
        ds.push(point);
        while (ds.length > maxPoints) ds.shift();
        scatterChart.update("none");
      }

      // ----- Stream handling -----
      function handleMetricBatch(metrics) {
        if (!Array.isArray(metrics) || metrics.length === 0) return;

        // pick newest (API typically returns desc)
        const latest = metrics[0];
        if (!latest) return;

        // normalize
        const p = {
          created_at: Number(latest.created_at || Date.now()),
          model: String(latest.model || "unknown"),
          tokens: Number(latest.tokens || 0),
          latency: Number(latest.latency || 0),
          token_efficiency: Number(latest.token_efficiency || 0),
          drift: Number(latest.drift || 0),
          waste_index: Number(latest.waste_index || 0),
          stress: Number(latest.stress || 0),
          prompt: String(latest.prompt || ""),
          response: String(latest.response || ""),
        };

        state.history.unshift(p);
        state.history = state.history.slice(0, 220);

        // KPIs
        els.kpiTokens.textContent = fmtInt(p.tokens);
        els.kpiLatency.textContent = fmtInt(p.latency);
        els.kpiModel.textContent = p.model;

        const gauge = wasteToGauge(p.waste_index);
        drawGauge(gauge);
        els.gaugeValue.textContent = String(gauge);
        els.gaugeMult.textContent = fmt(p.waste_index, 2) + "×";

        els.kpiWasteMult.textContent = fmt(p.waste_index, 2) + "×";
        els.kpiDrift.textContent = fmt(p.drift, 2);
        els.kpiStress.textContent = fmt(p.stress, 2) + "×";

        els.driftMeta.textContent = `latest ${fmt(p.drift, 2)} · alert at ${fmt(thresholds.drift, 2)}`;
        els.stressMeta.textContent = `latest ${fmt(p.stress, 2)}× · alert at ${fmt(thresholds.stress, 2)}×`;

        // Charts
        pushScatter({ x: p.latency, y: p.token_efficiency });
        pushSeries(driftChart, ts(p.created_at), p.drift, 60);
        pushSeries(stressChart, ts(p.created_at), p.stress, 36);

        // Heatmap
        renderHeatmap();

        // Alerts
        if (p.waste_index >= thresholds.waste) {
          playBeep();
          addAlert("WASTE", p, `${ts(p.created_at)} · waste ${fmt(p.waste_index, 2)}×`);
        }

        if (p.drift >= thresholds.drift) {
          addAlert("DRIFT", p, `${ts(p.created_at)} · drift ${fmt(p.drift, 2)}`);
        }

        if (p.stress >= thresholds.stress) {
          addAlert("STRESS", p, `${ts(p.created_at)} · stress ${fmt(p.stress, 2)}×`);
        }
      }

      function startSse() {
        setConn("warn");

        const es = new EventSource(SSE_URL);

        es.onopen = () => setConn("ok");
        es.onerror = () => setConn("bad");

        es.addEventListener("metrics", (evt) => {
          setConn("ok");
          try {
            const payload = JSON.parse(evt.data);
            handleMetricBatch(payload.metrics);
          } catch {
            // ignore
          }
        });

        // Fallback: some SSE endpoints send default messages.
        es.onmessage = (evt) => {
          try {
            const payload = JSON.parse(evt.data);
            if (payload && Array.isArray(payload.metrics)) {
              handleMetricBatch(payload.metrics);
            }
          } catch {
            // ignore
          }
        };

        return es;
      }

      // In case backend isn't live, keep UI alive with synthetic points.
      function startFallbackTelemetry() {
        let t = 0;
        setInterval(() => {
          if (state.history.length > 0) return;
          t += 1;
          const p = {
            created_at: Date.now(),
            model: "simulator",
            tokens: 200 + Math.round(Math.random() * 400),
            latency: 250 + Math.round(Math.random() * 1200),
            token_efficiency: 8 + Math.random() * 22,
            drift: Math.min(1, Math.max(0, 0.15 + Math.random() * 0.55)),
            waste_index: Math.max(0, Math.min(5, 1.2 + Math.random() * 2.7)),
            stress: Math.max(0.2, Math.min(6, 0.7 + Math.random() * 2.3)),
            prompt: "(synthetic) Explain semantic drift.",
            response: "(synthetic) Drift occurs when semantic units degrade relative to token output.",
          };
          handleMetricBatch([p]);
          if (t > 10) state.history = state.history.slice(0, 180);
        }, 2500);
      }

      async function initiateStressTest() {
        els.btnStress.disabled = true;
        els.btnStress.textContent = "Starting…";

        try {
          const res = await fetch(`${CONVEX_BASE}/api/red-team/start`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}),
          });

          if (!res.ok) throw new Error("red-team start failed");
          const json = await res.json();
          state.campaignId = json.campaignId || null;

          els.btnStress.textContent = "Stress Test Running…";
          addAlert("REDTEAM", {
            created_at: Date.now(),
            model: "red-team",
            tokens: 0,
            latency: 0,
            token_efficiency: 0,
            drift: 0,
            waste_index: 0,
            stress: 0,
            prompt: "",
            response: "",
          }, `Campaign ${state.campaignId || "(unknown)"} started`);

          pollRedTeamStatus();
        } catch {
          els.btnStress.textContent = "Initiate Stress Test";
          els.btnStress.disabled = false;
          addAlert("ERROR", state.history[0] || { created_at: Date.now() }, "Unable to start red-team campaign");
        }
      }

      async function pollRedTeamStatus() {
        if (!state.campaignId) {
          els.btnStress.textContent = "Initiate Stress Test";
          els.btnStress.disabled = false;
          return;
        }

        try {
          const res = await fetch(`${CONVEX_BASE}/api/red-team/status?campaignId=${encodeURIComponent(state.campaignId)}`);
          if (!res.ok) throw new Error("status failed");
          const json = await res.json();

          const status = json.status || "unknown";
          const done = Number(json.completed || 0);
          const total = Number(json.promptsGenerated || 0);

          els.btnStress.textContent = status === "completed" ? "Stress Test Complete" : `Stress Test ${done}/${total}`;

          if (status === "completed") {
            els.btnStress.disabled = false;
            addAlert("REDTEAM", state.history[0] || { created_at: Date.now() }, `Campaign complete · fragility ${fmt(json.fragility_score, 1)}`);
            await loadRedTeamResults();
            els.btnStress.textContent = "Initiate Stress Test";
            state.campaignId = null;
            return;
          }

          setTimeout(pollRedTeamStatus, 3000);
        } catch {
          els.btnStress.disabled = false;
          els.btnStress.textContent = "Initiate Stress Test";
        }
      }

      async function loadRedTeamResults() {
        if (!state.campaignId) return;

        try {
          const res = await fetch(`${CONVEX_BASE}/api/red-team/results?campaignId=${encodeURIComponent(state.campaignId)}`);
          if (!res.ok) return;
          const json = await res.json();

          const top = Array.isArray(json.results) ? json.results[0] : null;
          if (top && top.prompt) {
            openForensics({
              created_at: Date.now(),
              model: "red-team",
              tokens: 0,
              latency: 0,
              token_efficiency: 0,
              drift: 0,
              waste_index: top.waste_score || 0,
              stress: 0,
              prompt: String(top.prompt || ""),
              response: String(top.response || ""),
            }, "Top Red-Team Result (highest waste score)");
          }
        } catch {
          // ignore
        }
      }

      els.btnStress.addEventListener("click", initiateStressTest);
      els.btnClear.addEventListener("click", () => {
        state.alerts = [];
        renderAlerts();
      });
      els.heatmapRange.addEventListener("change", renderHeatmap);

      // boot
      drawGauge(0);
      renderHeatmap();
      startFallbackTelemetry();
      startSse();
    })();
  </script>
</body>
</html>
